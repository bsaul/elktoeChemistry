---
title: "alignment optimization"
author: "Bradley Saul"
date: "11/12/2018"
output: html_document
editor_options: 
  chunk_output_type: console
---

```{r}
test1 <- "P130-1"
# test2 <- "P148-1"
```

```{r, eval = FALSE}
# Calculate the valve lengths as measured by ruler
meas <- valve_measurements %>%
  mutate(idt = paste(id, transect, sep = "-")) %>%
  filter(idt %in% c(test1)) %>%
  group_by(idt) %>%
  filter(sum(grepl("ipx_", layer_transition)) > 0, sum(grepl("opx_", layer_transition)) > 0) %>%
  summarise(
    on_opx_distance = distance[grepl("_opx", layer_transition)],
    on_ipx_distance = distance[grepl("ipx_", layer_transition)], 
    valve_length = on_opx_distance - on_ipx_distance
  )  %>%
  select(idt, valve_length)
```

```{r, eval = FALSE}
rs <- function(x){
  ((x - max(x))/max(x)) + 1
}

chem <- valve_chemistry %>%
  mutate(idt = paste(id, transect, sep = "-")) %>%
  filter(idt %in% c(test1)) %>%
  select(idt, distance, pb = Pb208_CPS, ca = Ca43_CPS)

chem$pb[1:(floor(nrow(chem)/2))] <- rs(chem$pb[1:(floor(nrow(chem)/2))])
chem$pb[(ceiling(nrow(chem)/2)):nrow(chem)] <- rs(chem$pb[(ceiling(nrow(chem)/2)):nrow(chem)] )

chem <- chem %>%
  mutate(
    ca    = rs(ca),
    ca    = if_else(ca < 0.01, 0, ca),
    pb    = if_else(pb < 0.01, 0, pb),
    ratio = rs(pb/pmax(0.0001, ca)),
    # pb_slope = c(0, diff(pb)),
    rslope = c(0, diff(ratio))
  )
```

```{r, eval = FALSE}
lvalue <- meas %>% filter(idt == test1) %>% pull(valve_length)

chem %>%
  tidyr::gather(key = element, value = value, -idt, -distance) %>%
  ggplot(
    data = .,
    aes(x = distance, y = value, group = element, color = element)) +
  geom_line() + 
  geom_segment(
    aes(x = 72.025, xend = 72.025 + lvalue, y = -0.1, yend = -0.1),
    color = "black"
  ) + 
  facet_grid( ~ idt)
```


Optimization problem:

\begin{align*}
\text{minimize }  & \frac{| (d_i - d_j) - l|}{l} \\
\text{subject to } & i < \left \lceil{n_2}\right \rceil \\
 & j < \left \lfloor{n_2}\right \rfloor \\
\end{align*}

```{r}
f <- function(d, pb, ca, l){
  ca <- max(0.0001, ca)
  ratio <- pb/ca
  function(i, j){
    c(abs((d[j] - d[i]) - l)/l, ratio[i], ratio[j])
  }
}



lvalue <- meas %>% filter(idt == test1) %>% pull(valve_length)
dt <- chem %>%
  filter(idt == test1) 
dt
ff <- f(dt$distance, dt$pb, dt$ca, lvalue)

gen_indices <- function(dt){
  expand.grid(i = 1:floor(nrow(dt)/2), j = ceiling(nrow(dt)/2):nrow(dt))
}

idx <- gen_indices(dt)
idxs <- split(idx, 1:nrow(idx))

xxx <- lapply(idxs, function(x) ff(x$i, x$j))
xxx <- cbind(idx, do.call("rbind", xxx))
xxx
opt <- function(zzz){
  ids <- abs(zzz[ , 3]) < 0.01
  pb1 <- zzz[ , 4] > .0000001
  pb2 <- zzz[ , 5] > .0000001
  zzz <- zzz[ids, ]
  # zzz <- zzz[ids & (pb1 |  pb2), ]
  # print(zzz)
  # zzz[ , 6] <- (zzz[ , 4] + zzz[ , 5])/(zzz[ , 4] * zzz[ , 5])
  zzz
}

yyy <- opt(xxx)
yyy
plot(xxx[ , 4, yyy[ , 5]])
plot(yyy[ , 5])
yyy[which.max(yyy[ , 6]), ]

```


```{r}
library(magrittr)
library(ROI)
library(ROI.plugin.glpk)
library(ompr)
library(ompr.roi)



result <- MIPModel() %>%
  add_variable(x, type = "integer") %>%
  add_variable(y, type = "continuous", lb = 0) %>%
  set_bounds(x, lb = 0) %>%
  set_objective(x + y, "max") %>%
  add_constraint(x + y <= 11.25) %>%
  solve_model(with_ROI(solver = "glpk")) 
get_solution(result, x)
get_solution(result, y)
```
```{r}
test1 <-  MIPModel() %>%
  add_variable(i, lb = 1, ub = 4, type = "integer") %>%
  add_variable(j, lb = 6, ub = 10, type = "integer") %>%
  set_objective( i - j, "min") %>%
  solve_model(with_ROI(solver = "glpk", verbose = TRUE)) 

get_solution(test1, i) - get_solution(test1, j)
```

```{r}
x <- seq(.1, 1, by = 0.1)

f <- function(i, j){
  x[j] - x[i]
}

test2 <-  MIPModel() %>%
  add_variable(i, lb = 1, ub = 4, type = "integer") %>%
  add_variable(j, lb = 6, ub = 10, type = "integer") %>%
  set_objective( x[j] - x[i], "min") 

str(test2)
test2 %>% solve_model(with_ROI(solver = "glpk", verbose = TRUE)) 

eval(do.call('substitute', list(test2$objective$expression[[1]], list(i = 1, j = 2))))


test3 <-  MIPModel() %>%
  add_variable(x[i, j], i = 1:10, j = 1:10, type = "integer") %>%
  set_objective( x[j] - x[i], "min") 


test3 %>% solve_model(with_ROI(solver = "glpk", verbose = TRUE)) 


```


```{r}
testdt <- chem %>% filter(idt == test1)
n <- nrow(testdt)
lvalue <- meas %>% filter(idt == test1) %>% pull(valve_length)
# di <- testdt$distance
# do <- testdt$distance
distance <- testdt$distance


test <-  MIPModel() %>%
  add_variable(di, ub = testdt$distance[floor(n/2)], type = "continuous") %>%
  add_variable(do, lb = testdt$distance[ceiling(n/2)], type = "continuous") %>%
  set_objective( abs((do - di) - lvalue)/lvalue, "min") 

test <-  MIPModel() %>%
  add_variable(x, lb = 0, ub = floor(n/2), type = "integer") %>%
  add_variable(y, lb = ceiling(n/2), ub = n, type = "integer") %>%
  # add_variable(distance, type = "continuous") %>%
  set_objective( distance[y] - distance[x], "max") 


str(test)
test$objective
test %>%
  solve_model(with_ROI(solver = "glpk", verbose = TRUE)) 
x$solution


n <- 5
test <-  MIPModel() %>%
  add_variable(x[i], i = 1:n, type = "continuous") %>%
  add_variable(y[j], j = 1:n, type = "continuous") %>%
  set_objective( sum_expr(abs((x[i] - y[j]) - lvalue), i = 1:n, j = 1:n), "min") 

str(test)
test %>%
  solve_model(with_ROI(solver = "glpk", verbose = TRUE)) 
str(test)
get_solution(test)

  # add_variable(x[i], i = 1:150, type = "continuous") %>%
  # # add_variable(y, lb = 300, type = "continuous") %>%
  # # add_variable(d[j], j = 150:233, type = "continuous") %>%
  # set_objective( x[1],  sense =  "min")
test

MIPModel() %>%
 add_variable(x, lb = 2) %>%
 add_variable(y, lb = 40) %>%
 set_objective(x + y, sense = "min")
```
